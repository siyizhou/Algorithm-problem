# 冒泡排序
将待排序的元素看作竖着排列的气泡，较小的元素比较轻，从而要往上浮<br>
先比较相邻的元素，如果前一个比后一个大，就交换这两个数；<br>
对每一对相邻的数做相同的操作，从开始到结尾，最后的元素会是最大的数<br>
除去最后一个，针对所有的元素再重复以上步骤，直到没有任何一对数字进行比较<br>

冒泡排序的实现不考虑序列是否已经排好序<br>
冒泡算法的比较次数为（n-i）的加和，其中i从1到n-1<br>
所以执行效率为O(n2)<br>


# 选择排序
基本思想：对待排序的的记录序列进行n-1遍的处理，第i遍的处理是将A[i：n]中最小者与A[i]交换位置<br>
直接选择算法的关键字比较次数与对象的初始排序无关，第i遍选择的最小值对象，需要比较次数为n-i-1<br>
因此总的比较次数为（n-i-1）的加和，其中i从0到n-2<br>
因此，直接选择算法的时间性能为O(n2)<br>


# 插入序列
直接插入排序的基本思想是当插入第i个对象时，前面的A[0]，...，A[i-1]已经排好序<br>
这时，用A[i]与关键字A[i-1],A[i-2]..的关键字顺序进行比较<br>
插入位置即将A[i]插入，原来位置上的对象向后移<br>

在最坏的情况下，第i遍时第i个对象要和前面的i个对象都做关键字比较<br>
并且每做一次就要做一次数据移动<br>
则总的关键字比较次数以及和对象的移动次数分别为<br>
i的加和，其中i从1到n-1，约等于n2/2<br>
i+2的加和，其中i从1到n-1，约等于n2/2<br>
因此插入排序的时间性能为O(n2)<br>
最坏的情况下，复杂度为O(n2)<br>
最好的情况下，复杂度为O(n)<br>

# 快排
基本思想是基于分治法<br>
通过分割，将无序序列分成两部分，其中前一部分的元素值都小于后一部分的元素值<br>
然后每一部分再通过递归进行上述过程，直到每一部分的长度为1为止<br>

最坏的情况下，此时基准元素都是最小的元素，时间性能为O(n2)
最好的情况下，基准元素正好位于中间，时间性能为O(nlogn)<br>
平均时间性能为时间性能为O(nlogn)<br>

# 归并排序
核心思想：分治<br>
https://blog.csdn.net/k_koris/article/details/80508543<br>
python实现:<br>
https://www.cnblogs.com/Lin-Yi/p/7309143.html<br>

时间复杂度： 最好最坏都是 O(nlogn)<br>
稳定性：稳定<br>
缺点：每次拆分数组都要开心的数组， 每次合并数组都要开新数组，空间复杂度很大<br>

归并细节：比如有两个已经排序好的数组，如何将他归并成一个数组？<br>

我们可以开辟一个临时数组来辅助我们的归并。<br>
也就是说他比我们插入排序也好，选择排序也好多使用了存储的空间，也就是说他需要o（n）的额外空间来完成这个排序。<br>
只不过现在计算机中时间的效率要比空间的效率重要的多。无论是内存也好还是硬盘也好可以存储的数据越来越多，所以设计一个算法，时间复杂度是要优先考虑的。<br>

# 堆排序
https://www.cnblogs.com/chengxiao/p/6129630.html<br>
堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)<br>
<br>
堆是具有以下性质的完全二叉树：<br>
每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；<br>
或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br>

<br>
对堆中的结点按层进行编号，将这种逻辑结构映射到数组中<br>
该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：
大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]<br>  
小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2] <br>
<br>
如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：<br>
结点i的父节点在数组中的索引：parent(i) = floor((i - 1)/2)<br>
结点i的左子节点在数组中的索引：left(i)   = 2i + 1<br>
结点i的右子节点在数组中的索引：right(i)  = 2i + 2<br>

<br>
堆排序的基本思想是：<br>
将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。<br>
将其与末尾元素进行交换，此时末尾就为最大值。<br>
然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。<br>
如此反复执行，便能得到一个有序序列了<br>
<br>
步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。<br>
步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。<br>


# 桶排序
https://www.jianshu.com/p/204ed43aec0c<br>
桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，<br>
也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶，从值域上看是处于有序状态的。<br>
对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。<br>

<br>
快速排序是将集合拆分为两个值域，这里称为两个桶，再分别对两个桶进行排序，最终完成排序。<br>
桶排序则是将集合拆分为多个桶，对每个桶进行排序，则完成排序过程。<br>
两者不同之处在于，快排是在集合本身上进行排序，属于原地排序方式，且对每个桶的排序方式也是快排。<br>
桶排序则是提供了额外的操作空间，在额外空间上对桶进行排序，避免了构成桶过程的元素比较和交换操作，同时可以自主选择恰当的排序算法对桶进行排序。<br>

算法过程:<br>
根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；<br>
遍历待排序集合，将每一个元素移动到对应的桶中；<br>
对每一个桶中元素进行排序，并移动到已排序集合中。<br>
注：步骤 3 中提到的已排序集合，和步骤 1、2 中的待排序集合是同一个集合。<br>
与计数排序不同，桶排序的步骤 2 完成之后，所有元素都处于桶中，<br>
并且对桶中元素排序后，移动元素过程中不再依赖原始集合，所以可以将桶中元素移动回原始集合即可。<br>

桶排序的时间复杂度为O(N + N(log2 N - log2 M)),其中 M 表示桶的个数。<br> 
